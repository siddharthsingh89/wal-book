<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LMDB and Embedded Systems</title>


        <!-- Custom HTML head -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KVDQ13RXMY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KVDQ13RXMY');
</script>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-13-lmdb--embedded-systems"><a class="header" href="#chapter-13-lmdb--embedded-systems">Chapter 13: LMDB &amp; Embedded Systems</a></h1>
<h2 id="131-introduction"><a class="header" href="#131-introduction">13.1 Introduction</a></h2>
<p>LMDB (Lightning Memory-Mapped Database) is a high-performance, ultra-lightweight key-value store designed for reliability and speed. It is particularly well-suited for <strong>embedded systems</strong>, where resource constraints and real-time performance requirements demand efficient storage engines.</p>
<p>In this chapter, we will explore:</p>
<ul>
<li>The design principles of LMDB.</li>
<li>Why LMDB is ideal for embedded environments.</li>
<li>Memory-mapped storage and zero-copy access.</li>
<li>Transactional guarantees (ACID compliance).</li>
<li>Practical examples of using LMDB in embedded applications.</li>
<li>Performance tuning for constrained hardware.</li>
</ul>
<hr />
<h2 id="132-lmdb-fundamentals"><a class="header" href="#132-lmdb-fundamentals">13.2 LMDB Fundamentals</a></h2>
<h3 id="1321-key-features"><a class="header" href="#1321-key-features">13.2.1 Key Features</a></h3>
<ol>
<li><strong>Memory-Mapped Storage</strong>: LMDB maps the database file into the process’s address space. Reads are zero-copy and extremely fast.</li>
<li><strong>ACID Transactions</strong>: LMDB supports fully serializable transactions without locks for readers.</li>
<li><strong>Single-Level B+Tree</strong>: Uses a copy-on-write B+Tree, making writes safe and enabling consistent snapshots.</li>
<li><strong>No Fragmentation</strong>: LMDB avoids internal fragmentation through page-based allocation and reuse.</li>
<li><strong>Read-Optimized</strong>: Multiple readers can access the database simultaneously without blocking.</li>
</ol>
<h3 id="1322-database-structure"><a class="header" href="#1322-database-structure">13.2.2 Database Structure</a></h3>
<ul>
<li>LMDB uses <strong>fixed-size pages</strong>, typically 4 KB.</li>
<li>Keys and values are stored in <strong>B+Tree nodes</strong>.</li>
<li><strong>Copy-on-write</strong> ensures that updates do not overwrite active readers.</li>
</ul>
<hr />
<h2 id="133-why-lmdb-is-ideal-for-embedded-systems"><a class="header" href="#133-why-lmdb-is-ideal-for-embedded-systems">13.3 Why LMDB is Ideal for Embedded Systems</a></h2>
<p>Embedded systems often have limited CPU, memory, and storage. LMDB fits this scenario perfectly because:</p>
<ol>
<li><strong>Minimal Dependencies</strong>: LMDB is a single C library with no external dependencies.</li>
<li><strong>Small Footprint</strong>: It uses a fixed-size memory map and minimal heap allocations.</li>
<li><strong>High Throughput</strong>: Zero-copy reads and sequential writes leverage the OS page cache.</li>
<li><strong>Crash Safety</strong>: Copy-on-write ensures database consistency even on power failure.</li>
<li><strong>Predictable Latency</strong>: Since reads never block, performance is deterministic.</li>
</ol>
<p><strong>Example use cases in embedded systems:</strong></p>
<ul>
<li>IoT devices storing sensor logs.</li>
<li>Routers or network appliances storing configuration and routing tables.</li>
<li>Mobile apps needing reliable local storage.</li>
</ul>
<hr />
<h2 id="134-lmdb-transactions-in-embedded-systems"><a class="header" href="#134-lmdb-transactions-in-embedded-systems">13.4 LMDB Transactions in Embedded Systems</a></h2>
<h3 id="1341-read-only-transactions"><a class="header" href="#1341-read-only-transactions">13.4.1 Read-Only Transactions</a></h3>
<p>Read transactions are <strong>lock-free</strong> and lightweight:</p>
<pre><code class="language-c">MDB_txn *txn;
mdb_txn_begin(env, NULL, MDB_RDONLY, &amp;txn);
MDB_cursor *cursor;
mdb_cursor_open(txn, dbi, &amp;cursor);

MDB_val key, data;
while (mdb_cursor_get(cursor, &amp;key, &amp;data, MDB_NEXT) == 0) {
    printf("Key: %s, Value: %s\n", (char *)key.mv_data, (char *)data.mv_data);
}

mdb_cursor_close(cursor);
mdb_txn_abort(txn); // read-only transactions can be aborted
</code></pre>
<h3 id="1342-read-write-transactions"><a class="header" href="#1342-read-write-transactions">13.4.2 Read-Write Transactions</a></h3>
<p>Write transactions use <strong>copy-on-write</strong>, ensuring no active reader is blocked:</p>
<pre><code class="language-c">MDB_txn *txn;
mdb_txn_begin(env, NULL, 0, &amp;txn);

MDB_val key, data;
key.mv_size = strlen("device_id");
key.mv_data = "device_id";
data.mv_size = strlen("12345");
data.mv_data = "12345";

mdb_put(txn, dbi, &amp;key, &amp;data, 0);
mdb_txn_commit(txn);
</code></pre>
<hr />
<h2 id="135-memory-mapping-considerations"><a class="header" href="#135-memory-mapping-considerations">13.5 Memory Mapping Considerations</a></h2>
<ul>
<li>LMDB maps the entire database into the virtual memory of the process.</li>
<li>Embedded devices often have limited RAM; choose an appropriate <strong>map size</strong>:</li>
</ul>
<pre><code class="language-c">mdb_env_set_mapsize(env, 10 * 1024 * 1024); // 10 MB map
</code></pre>
<ul>
<li>The map size must be larger than your database. Expanding the map requires reopening the environment.</li>
</ul>
<hr />
<h2 id="136-performance-tuning-for-embedded-devices"><a class="header" href="#136-performance-tuning-for-embedded-devices">13.6 Performance Tuning for Embedded Devices</a></h2>
<ol>
<li><strong>Page Size</strong>: Default 4 KB is often ideal; smaller pages reduce RAM usage but may increase fragmentation.</li>
<li><strong>Batch Writes</strong>: Group multiple writes into a single transaction to minimize disk I/O.</li>
<li><strong>Read-Only Transactions</strong>: Use multiple concurrent readers for analytics or monitoring.</li>
<li><strong>Avoid Frequent Map Resizing</strong>: Pre-allocate a map large enough for future growth.</li>
</ol>
<hr />
<h2 id="137-lmdb-vs-other-embedded-databases"><a class="header" href="#137-lmdb-vs-other-embedded-databases">13.7 LMDB vs Other Embedded Databases</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>LMDB</th><th>SQLite</th><th>RocksDB</th></tr></thead><tbody>
<tr><td>Read Performance</td><td>Excellent</td><td>Good</td><td>Good</td></tr>
<tr><td>Write Performance</td><td>Good</td><td>Moderate</td><td>Excellent</td></tr>
<tr><td>Memory Usage</td><td>Low</td><td>Low</td><td>Moderate</td></tr>
<tr><td>ACID Compliance</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Complexity</td><td>Low</td><td>Low</td><td>High</td></tr>
<tr><td>Embedded-Friendly</td><td>Excellent</td><td>Excellent</td><td>Moderate</td></tr>
</tbody></table>
</div>
<p>LMDB is <strong>read-heavy optimized</strong> and excels in environments where reads dominate writes.</p>
<hr />
<h2 id="138-embedded-system-example-iot-device-log-storage"><a class="header" href="#138-embedded-system-example-iot-device-log-storage">13.8 Embedded System Example: IoT Device Log Storage</a></h2>
<p>Suppose we want to store sensor readings in an IoT device:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;lmdb.h&gt;

int main() {
    MDB_env *env;
    MDB_dbi dbi;
    MDB_txn *txn;

    mdb_env_create(&amp;env);
    mdb_env_set_mapsize(env, 2 * 1024 * 1024); // 2 MB
    mdb_env_open(env, "./sensor_db", 0, 0664);

    mdb_txn_begin(env, NULL, 0, &amp;txn);
    mdb_dbi_open(txn, NULL, 0, &amp;dbi);

    MDB_val key, data;
    key.mv_size = sizeof(int);
    key.mv_data = &amp;(int){1};
    data.mv_size = sizeof(double);
    double temp = 25.3;
    data.mv_data = &amp;temp;

    mdb_put(txn, dbi, &amp;key, &amp;data, 0);
    mdb_txn_commit(txn);

    mdb_dbi_close(env, dbi);
    mdb_env_close(env);
    return 0;
}
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>Each sensor reading is stored as a key-value pair.</li>
<li>LMDB ensures writes are atomic and consistent.</li>
<li>Reading the database requires no locks, even while writes happen.</li>
</ul>
<hr />
<h2 id="139-summary"><a class="header" href="#139-summary">13.9 Summary</a></h2>
<ul>
<li>LMDB is a <strong>lightweight, reliable, and fast</strong> key-value store ideal for embedded systems.</li>
<li>Its <strong>memory-mapped architecture</strong> enables zero-copy reads and high throughput.</li>
<li>Copy-on-write and ACID transactions make it <strong>crash-safe</strong>.</li>
<li>Performance tuning is crucial for constrained devices: map size, batch writes, and read optimization.</li>
<li>LMDB is widely used in embedded software, IoT devices, mobile apps, and network appliances.</li>
</ul>
<hr />
<h2 id="1310-lmdb-transactional-design-and-wal-like-mechanism"><a class="header" href="#1310-lmdb-transactional-design-and-wal-like-mechanism">13.10 LMDB Transactional Design and WAL-like Mechanism</a></h2>
<p>Unlike many traditional databases, LMDB does <strong>not use a separate Write-Ahead Log (WAL) file</strong>. Instead, it achieves <strong>atomicity, durability, and crash safety</strong> using <strong>memory-mapped files and a copy-on-write (COW) B+Tree</strong>. Let’s break this down.</p>
<hr />
<h3 id="13101-copy-on-write-cow-btree"><a class="header" href="#13101-copy-on-write-cow-btree">13.10.1 Copy-on-Write (COW) B+Tree</a></h3>
<p>LMDB’s core design revolves around a <strong>COW B+Tree</strong>, which ensures that <strong>writes never overwrite existing data in place</strong>:</p>
<ol>
<li>Each page in the database file is <strong>immutable once written</strong>.</li>
<li>Updates create <strong>new copies of the affected pages</strong>, leaving readers untouched.</li>
<li>Once the transaction commits, LMDB <strong>updates the root pointer</strong> to the new B+Tree root.</li>
<li>Readers always see a <strong>consistent snapshot</strong> of the database, even while writers are active.</li>
</ol>
<p><strong>Advantages of this design:</strong></p>
<ul>
<li><strong>Readers never block writers</strong>.</li>
<li><strong>Atomic commits</strong>: either the root pointer update succeeds or fails; partial writes are never visible.</li>
<li><strong>Crash safety without WAL</strong>: since old pages remain intact until commit, the database can always revert to the previous consistent state.</li>
</ul>
<hr />
<h3 id="13102-pseudo-wal-mechanism"><a class="header" href="#13102-pseudo-wal-mechanism">13.10.2 Pseudo-WAL Mechanism</a></h3>
<p>While LMDB doesn’t have a traditional WAL, it mimics <strong>WAL functionality</strong> in a lightweight way:</p>
<ul>
<li><strong>Transactional updates</strong>: New pages are written to free space in the memory-mapped file.</li>
<li><strong>Durability</strong>: On commit, LMDB updates the <strong>root page number</strong> in the database header and optionally flushes pages to disk (<code>mdb_env_sync</code>).</li>
<li><strong>Atomic root update</strong>: The root pointer acts as a single commit record, similar to the WAL commit record.</li>
<li><strong>Rollback support</strong>: If a crash occurs, uncommitted pages are simply ignored because the root pointer still points to the old tree.</li>
</ul>
<p><strong>Visualization:</strong></p>
<pre><code>[Old Tree Pages]         [New Tree Pages]
      |                        |
      v                        v
   Reader sees             Writer modifies pages
   Old root pointer          (COW)
                              |
                              v
                        Root pointer updated -&gt; commit
</code></pre>
<hr />
<h3 id="13103-transaction-commit-process"><a class="header" href="#13103-transaction-commit-process">13.10.3 Transaction Commit Process</a></h3>
<ol>
<li>
<p><strong>Begin transaction</strong>: Allocate new pages for updates.</p>
</li>
<li>
<p><strong>Write data to pages</strong>: Updates occur in private copies.</p>
</li>
<li>
<p><strong>Commit transaction</strong>:</p>
<ul>
<li>Flush modified pages to disk.</li>
<li>Atomically update root page pointer in DB header.</li>
</ul>
</li>
<li>
<p><strong>Readers continue using old root</strong> until next transaction.</p>
</li>
<li>
<p><strong>Free old pages</strong>: Pages from previous transactions that are no longer referenced are recycled.</p>
</li>
</ol>
<p>This ensures <strong>ACID compliance</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>How LMDB Implements It</th></tr></thead><tbody>
<tr><td>Atomicity</td><td>Root page pointer updated atomically; either old or new tree visible</td></tr>
<tr><td>Consistency</td><td>B+Tree structure maintained; page-level integrity checks</td></tr>
<tr><td>Isolation</td><td>Readers see snapshot of database at transaction start</td></tr>
<tr><td>Durability</td><td>Pages written to disk and root pointer updated atomically</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="13104-page-management--garbage-collection"><a class="header" href="#13104-page-management--garbage-collection">13.10.4 Page Management &amp; Garbage Collection</a></h3>
<p>LMDB uses a <strong>freelist system</strong> instead of log compaction:</p>
<ul>
<li>Modified pages are tracked during write transactions.</li>
<li>After a transaction commits, <strong>unused pages</strong> are added to a free list.</li>
<li>Next transaction can reuse pages without expanding the file.</li>
<li>This avoids <strong>fragmentation</strong> and ensures predictable memory usage.</li>
</ul>
<hr />
<h3 id="13105-comparison-to-traditional-wal"><a class="header" href="#13105-comparison-to-traditional-wal">13.10.5 Comparison to Traditional WAL</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Traditional WAL</th><th>LMDB (COW)</th></tr></thead><tbody>
<tr><td>Separate log file</td><td>Yes</td><td>No</td></tr>
<tr><td>Write amplification</td><td>Higher</td><td>Low</td></tr>
<tr><td>Crash recovery</td><td>Replay WAL</td><td>Root pointer rollback</td></tr>
<tr><td>Read/write concurrency</td><td>Often blocked</td><td>Readers never blocked</td></tr>
<tr><td>Disk space overhead</td><td>Extra log file needed</td><td>Only old pages (freelist)</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="13106-performance-implications"><a class="header" href="#13106-performance-implications">13.10.6 Performance Implications</a></h3>
<ol>
<li>
<p><strong>Reads are extremely fast</strong>:</p>
<ul>
<li>Memory-mapped pages allow direct access; no WAL replay required.</li>
</ul>
</li>
<li>
<p><strong>Writes are sequential and append-only</strong>:</p>
<ul>
<li>Copy-on-write writes to free pages; minimal disk seek.</li>
</ul>
</li>
<li>
<p><strong>Crash recovery is instant</strong>:</p>
<ul>
<li>Database can be reopened immediately; no log replay.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="13107-practical-tips-for-embedded-systems"><a class="header" href="#13107-practical-tips-for-embedded-systems">13.10.7 Practical Tips for Embedded Systems</a></h3>
<ul>
<li><strong>Map size</strong>: Ensure the memory-mapped file is large enough to accommodate growth and avoid frequent remapping.</li>
<li><strong>Commit frequency</strong>: Frequent small transactions can be slower due to flushing overhead; batch updates if possible.</li>
<li><strong>Read-heavy applications</strong>: LMDB excels because readers are non-blocking.</li>
<li><strong>Write-heavy embedded workloads</strong>: Optimize page size and map size; consider using multiple databases for partitioning.</li>
</ul>
<hr />
<h3 id="1311-summary-of-lmdb-wal-design"><a class="header" href="#1311-summary-of-lmdb-wal-design">13.11 Summary of LMDB WAL Design</a></h3>
<ul>
<li>LMDB <strong>does not need a separate WAL</strong>; copy-on-write B+Tree + atomic root pointer ensures crash-safe commits.</li>
<li>Embedded systems benefit from <strong>low memory usage, predictable performance, and high read concurrency</strong>.</li>
<li>LMDB’s approach eliminates the complexity of WAL management while providing <strong>full ACID guarantees</strong>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12_rocksdb.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="part4_distributed.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12_rocksdb.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="part4_distributed.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
